====================
===== LESSON 1 =====
====================

Чистая архитектура помогает тестировать код с помощью Unit тестов.

Структура курса
- принципы чистой архитектуры. как помогает тестировть код Unit тестами
- внедрение зависимостей
- архитекутра программных систем вообще и андроид приложений в частности
- что такое хорошая архитектура
- что такое и чем отличаются MVP, MVVM, MVI
- как решают проблемы сохранения состояний и навигации в приложении классические библиотеки Moxy и Cicerone

Научусь ориентироваться в многообразии архитектурных подходов в разработке под Андроид


====================
===== LESSON 2 =====
====================

План урока:
-- зачем нужна архитектура
-- что такое архитектура
-- требования к архитектуре

у людей ограничены возможности, им нужно отдыхать, человек не может запоминать большое количество информации, складывать большие числа в уме. Поэтому человечество изобрело компьютеры.
Чтобы возможности человека расширялись нужны приложения 
Для того, чтобы появились приложения необходимо писать программный код
Программный код может понимать и человек, и компьютер, но писать может только человек. Читает и понимает код человек гораздо медленнее компьютера. Читать его приходится гораздо чаще чем писать. Гораздо чаще достается старый проект в который необходимо внедрять новые фичи. В итоге маленькие приложения обрастают большим количество экранов и новых функций. Внедрять их становится все сложнее и сложнее. Потому что человеку сложно разобраться с тысячью строк в Main Activity

Ошибочно считать, что мобильные приложения простые. Мобильный разработчик должен уметь предусмотреть различные сценарии использования приложения, ограниченность в ресурсах, слабые мощности мобильных устройств, ограниченность батареи, не постоянное сетевое соединение и различные другие проблемы. Все это усложняется операционной системой Android. Например, проблема жизненного цикла и сохранения состояния, а также большем количестве устройств, работающих под этой системой. Все это означает, что объем кодовой базы мобильных приложений растет. Т.к. человеку сложно воспринимать большие объемы информации, то лучше если этот код разделен, изолирован и четко структуророван. Еще лучше использовать проверенные решения знакомые многим разработчикам. Это упрощает общение, включение новых людей в команду. 

Во всем этом поможет Архитектура. В любом коде есть свои проблемы, но хорошая архитектура поможет писать более качественный код, который будет меньше беспокоить людей, которые будут его читать. 

Термин пришел из строительства зданий

Архитектура здания абстрактно определяет его внешний вид, функцию, но не задает конкретных технических решений. т.к. этим будут заниматься другие люди.

Без проекта можно построить что-то простое, например, туалет.
Но если строить небоскреб, то очевидно что здесь необходимо долгое вдумчивое проектирование и подробный проект.

Архитектура -- совокупность решений, которые необходимо продумать зарание и которые тяжело изменить в дальнейшем.

Роберт Мартин (Дядя Боб) -- разработчик Agile, Clean code, SOLID. 

Android framework вынуждает нас наследоваться от классов Activities, Fragments, Services, Adapters и других. У разработчика часто возникает собланз оставить весь код в этих классах. Так появляются God object Activities, которые умеют отображать пользовательский интерфейс и ходить в сеть и делать запросы в базу данных.

В 2012 статья Мартина  The Clean Architecture. В ней содержатся основные принципы чистой архитектуры. Есть также видео с доклада, которое позволяет осветить некоторые моменты. Некоторые сущности несовсем подходят для Андроид разработки, но общие принципы подошли отлично.

Требования к Архитектуре
1. Независимость от фреймворков      - проект не должен быть тесно интегрировать в фреймворк на котором он написан. Например, вы можете переключиться с одного веб фреймворка на другой. Перенести основную логику приложения с Андроид на IOS
2. Тестируемость                     - код можно легко тестировать автоматическими средствами. Достигается высокой изолированность и слабой связанностью
3. Независимость от UI               - можно легко перейти от веб интерфейса на консольный и при изменении дизайна нет необходимость переписывать пол проекта
4. Независимость от базы данных      - в хорошой архитектуре есть возможность заменить одну СУБД на другую достаточно лекго.
5. Независимость от внешних факторов - основная логика ничего не знает о внешнем мире, никаких протоколах и технологиях, которые исользуются. Все это можно легко изменить.


Для простых проектов использоваться сложные архитектурные приемы необязательно.


====================
===== LESSON 3 =====
====================

Что такое каноническая чистая архитектура?

Слои
-- entities  - enterprise business rules
-- use cases - application business rules
-- controllers/presenters/gateways - interface adapters
-- UI/DB/WEB/Devices/External Interfaces - frameworks & drivers

Пример Интернет магазин
entities - может находиться заказ, товар, право формирования скидки. В Андроид здесь хранятся структуры данных. Вся логика здесь может использоваться без изменения на сервере, на web клиенте, на мобильном клиенте. Не должно быть упоминаний о способе доставки и хранении. Ни JSON, ни таблиц БД.

use cases - бизнес логика конкретного приложения. Какое-то неделимое действие, которое пользователь совершает над системой. Например, показ каталога товаров, изменение способа их сортировки, перемещение товара в корзину. При описании сценария используются термины предметной области, пример, бизнес сущность товар переместился в бизнесс сущность корзина. Сценарии использования говорят на языке бизнеса. Бизнесу не важно, что товары приходят в формате json, где-то кэшируются и хранятся. Важно лишь, что товар переместился в корзину.
Бизнес логика -- ведущий фактор в чистой архитектуре. Раньше в центре приложения стояла база данных.
Не влияют на внутренний слой и не зависят от внешнего слоя UI. Его затрагивают изменения в бизнес требованиях приложения. Таким может быть добавление подтверждения о добавлении товара в корзину. При этом не важно как это будет отображено пользователю

Аdapters -- размещается код, работающий с ползовательским интерфейсом, веб фреймворком или БД. Предполагается здесь размещать паттерн MVC, или весь используемый язык SQL

Frameworks -- все что связано с фремворком. Минимум кода, в идеале здесь не должно быть if-ов, потому что этот слой протестировать скорее всего не получится. 

При таком подходе Сценарии использования и Бизнес логика находятся впереди приложения, т.е. можно начинать реализацию приложения с нее и отложить выбор фремворков на потом.

Засчет изолированности слоев приложение легко тестировать. Также этот подход универсален и может использовать для любых приложений, фреймворков и патернов пользовательского интерфейса. Например, в Андроид давольно быстро меняются подходы, библиотеки.


====================
===== LESSON 4 =====
====================

Чистая архитектура в Android приложении
-- entities. редко сложная бизнесс логика уровня предприятия. Поэтому здесь располагаются простые струтуры данных
-- interactors - бизнесс логика уровня приложения. в канонической чистой архитектуре здесь находится Use cases. Интеракторы объединяются несколько сценариев использования в одном интерфейсе. Канонический use case - это один сценарий с методом execute
-- adapters - делятся на две части в зависимости с какой стороны находится пользователь
----- presenters - со стороны пользовательского интерфейса находятся презентеры, которые инкапсулируют в себе логику уронвя представления
----- repositories - находится с другой стороны, который чаще всего представляет из себя фасад для доступа к данным. Данные могут браться как из базы данных, из сети так и предоставляться сервисами операционной системы

Разделение внешних слоев на две части
Слои разделены на категории
-- presentation - представления
-- domain - бизнес логика
-- data - данные

Пользователь взаимодействует с пользовательским интерфейсом, который через презенторы передает управление в бизнес логику. Далее бизнес логика может получить какие-то данные из репозиториев, из БД, Сети, затем обработать их и обратно отобразить их через презенторы и пользовательский интерфейс.

В качестве объектов бизнес логики выступают Entities. Их возвращают и принимают Презенторы и Репозитории. В случае необходимости для преобразования одного формата данных в другой применяют Мапперы. Маппинг данных осуществляется в слое adapters

Чистая архитектура позволяет начасть разработку с бизнес логики и отложить детали технической реализации на потом

В интеракторе, если потребуется сложная бизнес логика например получить пользователей из нескольких репозиториев и выполнить над ними какие-то операции, то это выполняется в итеракторе. Если требования поступают от продуктового менеджера, то скорее всего они должны быить описаны в Интеракторе.

Интерактор общается с репозиторием через интерфейс Repository, чтобы избежать зависимостей на внешние слои. Репозиторий получает данные из источника данных, реализация которого находится в слое фреймворков.

Репозиторию не важно в каком формате поступают данные, если формат изменится, то Репозиторий и другие части приложения об этом не узнают.

====================
===== LESSON 5 =====
====================

План
-- структура пакетов
-- упрощения
-- тестирование


Структура пакетов
-- по слоям 
-- по функциям
-- комбинировать
-- модули

Есть два основных подхода по структуре пакетов: разделять код по слоям либо по функциям. По слоям разбивать легко. Напрмиер, если класс называется презентор, то мы его кладем в пакет с отальными презентарами. При этом область видимости пакетов позволяет отслеживать зависимости пакетов друг от друга. Разбивать код по функциям или сценариям сложнее. Трудно отнести класс к одного или другой задаче. Либо он может использоваться в нескольких сценариях. Но в случае удачного разбиения становится проще работать над задачей. Весь необходимый код находится рядом. Распространенной практикой является комбинация этих двух подходов. На верхнем уровне код делится по слоям, а внутри по фичам или наоборот. Существовал подход разделять слои на модули приложения для еще большей независимости, но он себя не оправдал. Однако может быть полезно вынести каждый сценарий использования со всеми слоями пользовательского интерфейса и данных для бизнес логики в отдельный модуль. Это позволит разделить ответсвенности разработчиков. Или команды разработки. Если каждый будет изменять код внутри своего модуля уменьшется количество конфликтов при слиянии кода. Также разделение на модули позволит использовать возможности InstantApps: скачивать на телефон не все приложение целеком, а только те функции, которые в данный момент нужны пользователю.

Пример структуры пакетов из реального проекта:
-- data                              - по фичам разложены реализации репозиториев и датасорсев
---- фичи (репозитории)              - 
-- di                                - код для внедрения зависимостей
-- domain (entities)                 - бизнес сущности
-- interactor                        - по фичам разложены интеракторы
---- фичи                            - 
-- repository (интерфейсы)           - разложены интерфейсы репозиториев, потому что они должны относиться к бизнес логике
-- ui                                - разложены по фичам презенторы и вью (активити или фрагменты)
---- фичи (presenters + activities)  - 

Упрощения в реализации чистой архитектуры под Android
-- entities где удобно без маппинга  - в большенстве случае даные полученные от сервера можно отобрать на экране. можно пойти на упрощение и использовать один тип данных во всех слоях. Иногда бывает, что формат данных полученный от сервера не очень хорошо подходит для отображения на экране или может измениться. Поэтому хорошо зарекомендовала практика маппинга всех json объектов в entity. Эт дает независимость от API. Далее entity объекты можно без изменения использовать в слое пользовательского интерфейса, если они хорошо подходят. Либо дополнительно преобразовывать в объекты UI слоя, если требуются изменения для отображения данных
-- RxJava вместо Input/Output Port   - может показаться лишней зависимостью от фреймворка, но это можно считать опраданным упрощением. Рассматривать rxjava как часть языка. Использовать стандартные подписки позволяет не писать лишние Iput/Outpu порты из канонического подхода
-- Объединять/убирать Interactor     - если считаете слой бизнес логики лишним, то можно им пренебречь и обращаться к слою репозиториев сразу из презеторов. Однако, если бизнес требования будут усложняться. Код бизнес логики появится в презентерах и репозиториях. У этих классов появится больше ответственности. И архитектура проекта ухудшится.
-- Glide/Picasso                     - загрузка картиного по url с помощь библиотек glide/picasso тоже типичное упрощение. Мы подразумеваем, что вью умеет отображать картинки по url и передаем только ссылку
-- Другое?                           - архитектура не должна мешать и иногда можно пойти на исключения отойти от канонического подхода и избежать написания большого количества кода

Переход к чистой архитектуре
-- новые экраны              - 
-- выделять presenter        - 
-- избавляться от singleton  - 
-- дробить презенторы дальше - 

можно начинать создавать с чистой архитектурой разделяя на вью и презентор вводя интеракторы и репозитории и не использую синглтоны. старые экраны можно рефактори по одному сужая границы перерабатываемого участка. начасть стоит с вынесения всего кода из активити в презентор во вью оставить только то, что там должно быть. далее уже можно работать с презентером постепенно выносить модули зависящие от Android, источники данных выводить в репозитории, синглтоны преобразовывать и все зависимости внедрять через конструкторы. Создавать зависимости можно с помощью тех же синглтонов либо сразу внедрять депендонси иджекшен в виде глобального апкомпонента. Нет ничего страшного, если презентор первое время будет отвечать за все. Рефакторинг можно проводить постепенно, помере необходимости внося изменения в старый код по требованию бизнеса.

Тестирование: зачем? -- одно из важнейших преимущест архитектуры является тестируемость кода. Тесты позволяют объективно оценить качество кода и вообще программы
-- объективный показатель качества
-- изменения, рефакторинг - тестируемый код дает больше уверенности при внесении изменений или рефакторинге. Если что-то сломали в коде, то красные тесты не дадут пропустить ошибку дальше. Таким образом тестирование умешает стоимость исправления ошибки ведь чем раньше она обнаружена тем дешевле ее исправить
-- TDD - можно писать код по методологии test driven development, сначало писать тесты, которые покрывают требуемы сценарий, затем код который их реализует, таким образом код будет гарантированно протестированным на 100%
-- можно закрыть неготовые части - часто бывает, что наш код зависит от еще не реализованных компонент системы. Например, реализуется фича, котора должна быть поддержана на бэкенде, но их разработчики не успевают ее реализовать. Можно утвердить контракт API, написать тесты на парсинг json для работы с rest api, например подставить mock сервер и быть уверенным, что мобильное приложение работает корректно, когда сервер еще не готов. В идеальном случае, если контракт будет соблюден останется только подключить сетевой копонент и все заработает. Похожим образом можно поступить с пользовательским интерфейсом, когда дизайн еще не готов.

Unit vs UI
-- не требует Android
-- быстро выполняются 
-- дешевле писать
-- надежнее
-- покрывают только часть



====================
===== LESSON 7 =====
====================

 Инверсия зависимтостей

 План:
 - принцип инверсии зависимостей

 Нельзя создавать зависимости в методах
 Нельзя использовать статические методы зависимостей в методах

 Оба случая создают жесткую связь и 

 Проблемы
 -- сложно изменять
 -- сложно тестировать

 Инверсия зависимостей
 - SOLI"D": Dependency Inversion Principal
 -- модули верхних уровней не должны зависить от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций
 -- абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

 Программные системы принято разделять на слои по уровню абстракции. В наивной интерпретации слои более высокого уровня зависят от слоев более низкого уровня. Например, бизнес логика приложения управляет сетевыми запросами и начинает зависеть от реализации низкоуровневого фреймворка. При такой реализации изменения в нижних слоях транзитивно распростараняются на верхний. Переиспользование бизнес логики практически не возможно. Система получается жестко связанной и трудно изменяемой.

 Другой подход. Верхний слой работает не снижним, а со специальным интерфейсом, потребности которого определяются более верхним уровнем. При этом он также находится в верхнем слое и зависимость разрушена. Класс зависит от интерфейса, который также находится в этом слое. Слой более низкого реализует потребность более верхнего уровня, т.е. его интефейс. Изменение направления между слоями и назвают инверсией зависимостей. Раньше верхний слой зависил от нижнего слоя, теперь нижний слой зависит от верхнего. При этом может изменить реализацию ниженего слоя и верхний об этом не узнает.

 Это первое правило: модули верхнего уровня не должны зависить от модулей нижнего уровня. Оба типа модулей должны зависить от абстракций.

 Абстракции зависят от деталей

 Button <>------- Lamp

 В наивной реализации кнопка включает в себя лампу и управляет ею. Таким образом реализация кнопки напрямую зависиот от реализации лампы, т.е. при изменении кода лампы будет и изменен код кнопки. Также кнопка не сможет быть переиспользована например для управления мотором. Эта реализация нарушает принцип инверсии зависимостей. Высокий уровень логики не отделен от низкого уровня реализации. Абстракция не отделена от деталей. Без такого разделения логика автоматически связана с низкоуровневой реализацией. Абстракции зависят от деталей.

 Button implementation --> Abstract Button <>------ Abstract ButtonClient <--- Lamp 

 Абстрактная кнопка взаимодействует с абстрактным клиентом кнопки. Детали реализации кнопки зависят от абстракции. Детали реализации зависят от деталей реалзиции клиента кнопки. Таким образом можно подменять реализацию кнопки и клиента кнопки.

 Важно не зависить от конкретной реализации.